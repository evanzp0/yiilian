# <center>BitTorrent Protocol 规范 v2</center>

BitTorrent 是一个用于文件分发的协议，它通过 URL 来标识内容，并被设计成与 web 无缝集成。它的相对于一般 HTTP 的优势在于，当相同的文件有多个下载并发进行时，下载者之间可互传数据，这使得文件源在仅增加少量负载的情况下就能支持数量众多的下载成为可能。

## 一个 BitTorrent 文件分发由以下实体组成：
- 一个普通的 web 服务器
    > *译注：存放 .torrent 种子文件的 web 服务器，比如可以下载附件的论坛等等*
- 一个静态的 'metainfo' 文件
    > *译注：这是以 .torrent 为扩展名的种子文件，它相当于是被下载资源文件的一个概述*
- 一个 BitTorrent tracker 服务器
    > *译注：让下载同一个文件的多个下载器之间能互相认识的一个服务器*
- 一个 '下载源' ('original' downloader)
    > *译注：拥有被下载资源文件 100% 内容，并将其提供给别人下载的下载器，俗称 '做种者'*
- 终端用户 web 浏览器
    > *译注：终端用户通过 web 浏览器，在 web 服务器上下载到 .torrent 种子文件*
- 终端用户下载器(downloader)
    > *译注：终端用户通过下载器 (downloader)，下载 .torrent 种子文件对应的资源文件*

理想情况下，一个单独的文件有多个终端用户在下载。

## 要提供 Bittorent 下载服务，主机端需要执行以下步骤：

1. 启动运行一个 tracker 服务器(或者，更可能的是有一个已经运行的 tracker)。
2. 启动运行一个普通的 web 服务器，比如 apache ，或者有一个已经运行的。
3. 在该 web 服务器上将 `.torrent` 扩展名和 `mimetype applicaton/x-bittorrent` 进行关联（或者已经完成此操作）。
4. 使用要发布的完整文件和 tracker 服务器的 url，生成一个 `metainfo` (`.torrent`) 文件。
5. 将 `metainfo` 文件放到 web 服务器上。
6. 将 `metainfo` (`.torrent`) 文件的链接放入某个 web 页面中。
7. 启动一个已经有了完整文件的 downloader (the 'origin')

> *译注：总结一下，提供 BitTorrent 文件下载服务，需要如下步骤：*
>
> *1. 启动 Tracker 服务。*
> *2. `.torrent` 文件的生成和发布：这包括根据要发布的文件本身的内容和 Tracker 服务器的 URL 生成 `metainfo` 文件，即 `.torrent` 文件，tracker 服务器地址被写入 .torrent 文件中；将 `.torrent` 文件发布到 Web 服务器上，提供对该 `.torrent` 文件的下载服务；将 `.torrent` 文件的链接尽可能的传播出去。*
> *3.启动提供文件的下载源。*
>
> *真正用于实际的文件下载的组件是 Tracker 服务器，和文件的下载源节点。*

## 要启动下载，用户需要执行以下步骤：

1. 安装 BitTorrent (或已经安装完成该操作)。
2. 浏览 web 。
3. 点击 `.torrent` 文件的链接。
4. 选择保存资源文件的本地路径，或者选择一个部分下载的资源文件并恢复下载。
5. 等待下载完成。。
6. 退出下载器 (它会持续上传数据直到退出)

> *译注：总结一下，BitTorrent 文件下载有两个过程：*
> *一是下载 `.torrent` 文件；*
> *二是使用 BitTorrent 客户端下载文件，数据的来源将是网络中包含文件数据的其它节点。*

## Bencode 编码

- 字符串(string)表示为：十进制的长度前缀，后接冒号和字符串本身。
    *例如：`spam` 的编码为 `4:spam`*
- 整数(integer)表示为：`i`开头，后接十进制的数字，然后跟一个 `e` 表示结束。
    *例如：`3` 的编码为 `i3e`；`-3` 的编码为 `i-3e`*
    整数没有大小限制，`i-0e` 是无效的。除了表示 0 的 `i0e` 以外，所有以 0 为开头的编码，比如：`i03e`，都是无效的。
- 列表(list)表示为：`l` 开头，后接列表元素（这些元素也是 B 编码的），然后用 `e` 表示结束。
     *例如：`['spam', 'eggs']` 的编码为 `l4:spam4:eggse`*
- 字典(dictionary)表示为：`d`开头，后面交替跟着 `key` 及其对应的 `value` ，然后用 `e` 表示结束。
    *例如： `{'cow': 'moo', 'spam': 'eggs'}` 的编码为 `d3:cow3:moo4:spam4:eggse`; `{'spam': ['a', 'b']}` 的编码为 `d4:spaml1:a1:bee`*
   **Key 必须为字符串并且顺序排列（按照原始字符（raw string）串排序，而不是字母顺序）**

> *译注： `BitTorrent` 协议发明了一种编码方式，即 `Bencode` 。 `Bencode` 编码有 4 种数据类型，即字符串，整数，列表，和字典（即映射）。基本数据类型是字符串和数字，列表和字典则是两种最常用的容器类型。*
> raw string 排序: 按照二进制编码的大小排序，比如 '10' 和 '2' 两个字符串从小到大排序，'10' 排在 '2' 前面，因为 '1' 的 二进制编码小于 '2' 的二进制编码。

请注意，在 bencoding 的上下文中，包括字典的 key 在内的字符串是任意的字节序列（uint8_t[], 就是二进制字节，即使它不存在对应的 ascii 或 unicode）。

BEP 的作者建议使用与 ASCII 兼容的字符串作为字典键，并使用 UTF-8 编码人类可读的数据。不过，具体实现不能依赖于此规定。

## metainfo 文件

Metainfo 文件（也就是以 `.torrent` 为扩展名的文件）被编码为 bencode 字典，具有以下 key：

**announce**

    表示 tracker 的 URL 。

**info**

    它的值是一个字典，接下来会描述该字典中的 key 。

**piece layers**

    这是一个字符串字典。对于文件树中每个大于 piece 长度的文件，它包含一个字符串值。它的 key 是默克尔根，而 values 由该默克尔树中某一层内的哈希值的连接组成。所选层使得一个哈希值覆盖片长度的字节。例如，如果片大小为16KiB，则使用叶哈希值。如果使用的片大小为128KiB，则使用从叶哈希值起算的第三层。仅覆盖文件末尾之外的数据（即仅用于平衡树）的层哈希值被省略。所有哈希值都以其二进制格式存储。

    如果此字段缺失、所含哈希值与默克尔根不匹配或不是来自正确层，则该torrent无效。

> **译者注：** 默克尔树是一种特殊的二叉树，它的每个节点都存储了一个数据块的哈希值。对于叶子节点，它们存储的是数据块本身的哈希值；而对于非叶子节点，它们存储的是其子节点哈希值组合的哈希值。这样，当所有数据块的哈希值都被计算并组合后，最终会得到一个根节点的哈希值，这个值就是默克尔根。
> 
> 举个例子来说，假设你有一个 torrent 文件，它包含了 4 个数据块 A、B、C、D。首先，你会对每个数据块计算哈希值，得到 H(A)、H(B)、H(C)、H(D)。然后，你会将这些哈希值两两组合并再次计算哈希值，得到两个中间节点的哈希值 H(H(A) + H(B)) 和 H(H(C) + H(D))。最后，这两个中间节点的哈希值再次组合并计算哈希值，得到的就是默克尔根。
> 
> 在 torrent 文件的下载和验证过程中，默克尔根起到了至关重要的作用。通过比较下载的 torrent 文件中包含的默克尔根与服务器上的默克尔根是否一致，用户可以快速判断下载的数据是否完整且未被篡改。

## info 字典

- `name` 的值是一个 UTF-8 编码的字符串，建议用它作为保存文件或目录的名字。这存粹只是建议。

- `piece length` 的值是一个数字，代表文件分片的大小。为了便于传输，文件被分割为固定大小的分片，除了最后一片由于截断导致长度可能与众不同外，所有分片的长度都是相同的。`piece length` 几乎总是 2 的幂，最常见的是 2 ^ 18 = 256 K （BitTorrent 在 3.2 版之前使用 2 ^ 20 = 1M 作为默认值）。

- `pieces` 的值是一个字符串，它的长度是 20 的整数倍。它被分段为单个长度为 20 的若干字符串，每个分段字符串，都是其分段索引对应的文件分片的 SHA1 hash 值。

- 还有一个 `length` 或 `files` 的 key，但它们有且只能有其中一个出现。如果出现 `length` ，那么代表下载的是一个单个的文件，否则，代表下载的是一个目录结构下的一系列文件。

    单个文件的情况下， `length` 表示文件的字节长度。

    出于其他键的目的，多文件的情况，仅被看作将 `files` 列表中出现的文件，按顺序连接形成的单个文件。

    > *译注：这句话的意思是，从 `pieces` 这种 key 的角度看，多个文件实际上是按顺序连接成一个大文件，然后进行分片处理。*

- `files` 的值是文件列表 ，它的元素是包含以下 key 的字典：

    - `length` - 文件的长度，以字节为单位。
    - `path` - UTF-8编码的字符串，其中有相应的子目录名和文件名（ path 字符串的长度不可为 0 ）

单个文件情况下，`name` 的值可作为文件名；多个文件的情况下，`name` 的值可作为目录名。

> *译注：用 JSON 来表示 .torrent 文件使我们可以对这种文件格式的结构有更清晰的认识。*

```
// 单个文件的 .torrent 文件结构
{
    "announce":"xxxx",
    "info":{
        "length":"xxxx",
        "name":"xxxx",
        "piece length":"xxxx",
        "pieces":"xxxx"
    }
}
```

```
// 多个文件的 .torrent 文件结构
{
    "announce":"xxxx",
    "info":{
        "files":[
            {
                "length":"xxxx",
                "path":"xxxx"
            },
            {
                "length":"xxxx",
                "path":"xxxx"
            },
            {
                "length":"xxxx",
                "path":"xxxx"
            }
        ],
        "name":"xxxx",
        "piece length":"xxxx",
        "pieces":"xxxx"
    }
}
```
