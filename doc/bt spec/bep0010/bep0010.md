# <center>Extension Protocol 规范</center>

该协议的目的是为 BitTorrent 协议的扩展提供一个简单精简的传输。支持此协议可以轻松添加新的扩展，而不会干扰到标准 BitTorrent 协议，也不会干扰不支持此协议的客户端。

为了告知其他客户端你支持此协议，（ `handshake` 帧中）保留字节 (`reserved_byte`) 的一位会被使用。

用于标识扩展协议的是 (保留字节) 中右数第 20 位（计数从 0 开始）。因此使用表达式 `reserved_byte[5] & 0x10` 可以验证对方客户端是否支持扩展协议的消息。

一旦对此协议的支持建立起来（双方在握手中都声明支持此协议），客户端将支持一个新类型的消息( peer message )：

| name | id |
| - | - |
| extended | 20 |

该消息和发送其他 bittorrent 消息一样，使用 4 个字节的长度前缀，1 个单独的标识消息类型的字节（此时该字节的值为 20）。在消息 playload 开头，是一个单独的消息标识字节 (扩展消息 ID)，该标识能引用不同的扩展消息，并且有一个 ID 为 0 的消息。如果 ID 为 0，这个消息就是扩展协议的握手消息。一般扩展消息的布局如下（列表包含了 BitTorrent 协议使用的 peer message 的头）：

| size | description | |
| - | - | - |
| uint32_t | 长度前缀。指明了整个消息的字节数 (使用大端序)  | peer message header |
| uint8_t  | bittorrent peer message ID，= 20 | peer message header |
| uint8_t  | extend message ID。 0 = handshake，>0 = 取 handshake 中声明的扩展消息 ID | ext message |

换个方式描述，可能看上去会直观些：

```
| <peer_msg_len = 2 + X> : int(4) | <peer_msg_id = 20> : int(1) | <ext_msg_id> : int(1) | <payload> : byte(X) |
```

> *译注：extended message ID = 0 表示是 handshake，它的 payload 含有该 peer 所支持的所有扩展消息 ID；当 extended message ID > 0 时，它的值需要和本地发送的 handshake payload 中声明的 extended message ID 一致*
>
> *接下来讨论扩展消息时，都不再赘述 peer message 头部。*

## Handshake 消息

`handshake` 消息的 payload 是一个 bencode 编码的字典。字典中所有的 item 都是可选的。客户端应当忽略任何未知的名字的 item 。该字典的内容都是大小写敏感的。以下是字典中定义的 item ：

| name | description |
| - | - |
| m | 所支持的扩展消息的字典表，用于将**扩展消息名**映射到**扩展消息ID**。唯一的约束是，扩展消息不可以使用相同的 ID。如果 ID = 0，则表示不支持或已禁用该扩展。客户端应该忽略未知的扩展名。

扩展消息 ID ，是用于向发送此 handshake 消息的 peer ，继续发送扩展消息时使用的 ID。即这些 ID 是 我方支持的扩展消息的本地 ID （不是对方 peer 支持的 扩展消息 ID） |

下面是在实现时可能会选择支持的一些其他的 item：

| name | description |
| - | - |
| p | 