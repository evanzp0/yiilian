# <center>BitTorrent Protocol 规范</center>

BitTorrent 是一个用于文件分发的协议，它通过 URL 来标识内容，并被设计成与 web 无缝集成。它的相对于一般 HTTP 的优势在于，当相同的文件有多个下载并发进行时，下载者之间可互传数据，这使得文件源在仅增加少量负载的情况下就能支持数量众多的下载成为可能。

## 一个 BitTorrent 文件分发由以下实体组成：
- 一个普通的 web 服务器
    > *译注：存放 .torrent 种子文件的 web 服务器，比如可以下载附件的论坛等等*
- 一个静态的 'metainfo' 文件
    > *译注：这是以 .torrent 为扩展名的种子文件，它相当于是被下载资源文件的一个概述*
- 一个 BitTorrent tracker 服务器
    > *译注：让下载同一个文件的多个下载器之间能互相认识的一个服务器*
- 一个 '下载源' ('original' downloader)
    > *译注：拥有被下载资源文件 100% 内容，并将其提供给别人下载的下载器，俗称 '做种者'*
- 终端用户 web 浏览器
    > *译注：终端用户通过 web 浏览器，在 web 服务器上下载到 .torrent 种子文件*
- 终端用户下载器(downloader)
    > *译注：终端用户通过下载器 (downloader)，下载 .torrent 种子文件对应的资源文件*

理想情况下，一个单独的文件有多个终端用户在下载。

## 要提供 Bittorent 下载服务，主机端需要执行以下步骤：
1. 启动运行一个 tracker 服务器(或者，更可能的是有一个已经运行的 tracker)。
2. 启动运行一个普通的 web 服务器，比如 apache ，或者有一个已经运行的。
3. 在该 web 服务器上将 `.torrent` 扩展名和 `mimetype applicaton/x-bittorrent` 进行关联（或者已经完成此操作）。
4. 使用要发布的完整文件和 tracker 服务器的 url，生成一个 `metainfo` (`.torrent`) 文件。
5. 将 `metainfo` 文件放到 web 服务器上。
6. 将 `metainfo` (`.torrent`) 文件的链接放入某个 web 页面中。
7. 启动一个已经有了完整文件的 downloader (the 'origin')

> *译注：总结一下，提供 BitTorrent 文件下载服务，需要如下步骤：*
>
> *1. 启动 Tracker 服务。*
> *2. `.torrent` 文件的生成和发布：这包括根据要发布的文件本身的内容和 Tracker 服务器的 URL 生成 `metainfo` 文件，即 `.torrent` 文件；将 `.torrent` 文件发布到 Web 服务器上，提供对该 `.torrent` 文件的下载服务；将 `.torrent` 文件的链接尽可能的传播出去。*
> *3.启动提供文件的下载源。*
>
> *真正用于实际的文件下载的组件是 Tracker 服务器，和文件的下载源节点。*

## 要启动下载，用户需要执行以下步骤：
1. 安装 BitTorrent (或已经安装完成该操作)。
2. 浏览 web 。
3. 点击 `.torrent` 文件的链接。
4. 选择保存资源文件的本地路径，或者选择一个部分下载的资源文件并恢复下载。
5. 等待下载完成。。
6. 退出下载器 (它会持续上传数据直到退出)

> *译注：总结一下，BitTorrent 文件下载有两个过程：*
> *一是下载 `.torrent` 文件；*
> *二是使用 BitTorrent 客户端下载文件，数据的来源将是网络中包含文件数据的其它节点。*

## Bencode 编码
- 字符串(string)表示为：十进制的长度前缀，后接冒号和字符串本身。
    *例如：`spam` 的编码为 `4:spam`*
- 整数(integer)表示为：`i`开头，后接十进制的数字，然后跟一个 `e` 表示结束。
    *例如：`3` 的编码为 `i3e`；`-3` 的编码为 `i-3e`*
    整数没有大小限制，`i-0e` 是无效的。除了表示 0 的 `i0e` 以外，所有以 0 为开头的编码，比如：`i03e`，都是无效的。
- 列表(list)表示为：`l` 开头，后接列表元素（这些元素也是 B 编码的），然后用 `e` 表示结束。
     *例如：`['spam', 'eggs']` 的编码为 `l4:spam4:eggse`*
- 字典(dictionary)表示为：`d`开头，后面交替跟着 `key` 及其对应的 `value` ，然后用 `e` 表示结束。
    *例如： `{'cow': 'moo', 'spam': 'eggs'}` 的编码为 `d3:cow3:moo4:spam4:eggse`; `{'spam': ['a', 'b']}` 的编码为 `d4:spaml1:a1:bee`*
    Key 必须为字符串并且顺序排列（按照原始字符（raw string）串排序，而不是字母顺序）

> *译注： `BitTorrent` 协议发明了一种编码方式，即 `Bencode` 。 `Bencode` 编码有 4 种数据类型，即字符串，整数，列表，和字典（即映射）。基本数据类型是字符串和数字，列表和字典则是两种最常用的容器类型。*

## metainfo 文件
Metainfo 文件（也就是以 `.torrent` 为扩展名的文件）被编码为 bencode 字典，具有以下 key：

**announce**

    表示 tracker 的 URL 。

**info**

    它的值是一个字典，接下来会描述该字典中的 key 。

## info 字典

- `name` 的值是一个 UTF-8 编码的字符串，建议用它作为保存文件或目录的名字。这存粹只是建议。

- `piece length` 的值是一个数字，代表文件切片的大小。为了便于传输，文件被分割为固定大小的切片，除了最后一片由于截断导致长度可能与众不同外，所有切片的长度都是相同的。`piece length` 几乎总是 2 的幂，最常见的是 2 ^ 18 = 256 K （BitTorrent 在 3.2 版之前使用 2 ^ 20 = 1M 作为默认值）。

- `pieces` 的值是一个字符串，它的长度是 20 的整数倍。它被分段为长度为 20 的若干字符串，每个分段字符串，都是其分段索引对应的文件切片的 SHA1 hash 值。

- 还有一个 `length` 或 `files` 的 key，但它们有且只能有其中一个出现。如果出现 `length` ，那么代表下载的是一个单个的文件，否则，代表下载的是一个目录结构下的一系列文件。

    单个文件的情况下， `length` 表示文件的字节长度。

    出于其他键的目的，多文件的情况，仅被看作将 `files` 列表中出现的文件，按顺序连接形成的单个文件。

    > *译注：这句话的意思是，从 `pieces` 这种 key 的角度看，多个文件实际上是按顺序连接成一个大文件，然后进行切片处理。*

- `files` 的值是文件列表 ，它的元素是包含以下 key 的字典：

    - `length` - 文件的长度，以字节为单位。
    - `path` - UTF-8编码的字符串，其中有相应的子目录名和文件名（ path 字符串的长度不可为 0 ）

单个文件情况下，`name` 的值可作为文件名；多个文件的情况下，`name` 的值可作为目录名。

> *译注：用 JSON 来表示 .torrent 文件使我们可以对这种文件格式的结构有更清晰的认识。*

```
// 单个文件的 .torrent 文件结构
{
    "announce":"xxxx",
    "info":{
        "name":"xxxx",
        "piece length":"xxxx",
        "pieces":"xxxx",
        "length":"xxxx"
    }
}
```

```
// 多个文件的 .torrent 文件结构
{
    "announce":"xxxx",
    "info":{
        "name":"xxxx",
        "piece length":"xxxx",
        "pieces":"xxxx",
        "files":[
            {
                "length":"xxxx",
                "path":"xxxx"
            },
            {
                "length":"xxxx",
                "path":"xxxx"
            },
            {
                "length":"xxxx",
                "path":"xxxx"
            }
        ]
    }
}
```

## tracker

Tracker 的 Get 请求有以下 key:

- **info hash**
    它是将 `metainfo` 文件中 `info` 的 bencode 编码值，进行 SHA1 后得到的 20个字节的 hash 值。由于要通过 http get 将该值作为参数值向 tracker 发送请求，所以几乎肯定要该值进行 (URL) 转码。

    注意，这是 `metainfo` 文件的一个子字符串。`info-hash` 必须是 .torrent 中找到的已编码的子字符串的 hash 值，它等同于，先用 bencode 解码 `metainfo` 文件，接着**完全校验解码后的内容**（ 比如 key 的排序，没有前导 0 ），校验通过后提取 `info` 的值进行 bencode 编码。换句话说，这意味着客户端不能使用无效的 `metainfo` 文件，也不能直接使用提取的 bencode 子字符串。
    > *译注：这里是指，不能直接使用提取的 `info` 的 bencode 的值进行 hash，需要先校验其有效性*。
    
    它们不得在无效得数据上进行解码和编码循环
    > *译注：这里是指，如果 `metainfo` 文件是无效的，那不仅经过校验，就对 `info` 的值进行 bencode 解码，然后再进行 bencode 编码，最终得到得 hash 将是错误的*。

- **peer_id**
   向 tracker 发起请求的 downloader 的 id，它是一个长度为 20 的字符串。**Downloader 应在每次开始一个新的下载任务时重新随机生成一个新的 peer_id**，该值也几乎肯定要会被 (URL) 转码。

- **ip**
    一个可选的参数，它给出了这个 peer 的 IP (或域名)。如果 peer 与 tracker 位于相同机器的话，会使用该参数作为 peer 的源（地址），否则通常不需要。
    > *译注：*
    > - *一般情况下该参数没有必要, 因为传输层 (Transport Layer, 如 TCP) 本身可以获取 IP 地址, 但如果 BT 下载器通过 Proxy 与 Tracker 交互时, 该在该字段中设置源端的真实 IP 。*
    > - *另外，如果 peer 和 tracker 位于同一台机器，那么通过传输层获得的地址是可能是 127.0.0.1，这个地址是不能和外网的 peer 进行通信的，所以要指定一个 peer 的外网 IP 才行 。*

- **port**
    port 是 peer 监听的端口号。Downloader 通常的行为是去监听 6881 端口，如果该端口被占用，则去尝试监听 6882、6883 以此类推直到 6889， 如果还没成功则放弃。

- **upload**
    到目前为止上传的数据量，使用 10 进制 ascii 编码。

- **downloaded**
    到目前为止下载的数据量，使用 10 进制 ascii 编码。

- **left**
    当前 peer 仍需下载的的字节数，使用 10 进制 ascii 编码。
    注意，这个值不能用文件的长度和已经下载的数据量来计算，因为它可能是恢复的下载，而且，也有可能下载的一些数据在完整性检查时失败，而不得不重新下载。

- **event**
    这是一个可选的 key，它可取值为 `started`，`completed` ，或 `stopped`(或者为空，这与没有这个 key 一样)。如果没这个 key，那就意味着这是一个定期进行的通告 (announcement)。
    在首次下载开始时，会发送一个 `started` 通告；在下载结束时发，会发送一个  `completed` 通告；如果启动时文件已是完整的，则不会发送 `completed` 通告。当停止下载时，downloader 会发送一个 `stopped` 通告。

> *译注：看下 tracker 收到的 GET 请求，可以有一个更直观的认识*
```
GET /announce?info_hash=j%25%7c%fe%12%0e%c0%9d%ee6%d5%df%03%bb%fda%cd%7b%97%b5&peer_id=-qB451%20-1MTFo0SteXN2&port=22387&uploaded=0&downloaded=0&left=0&corrupt=0&event=started&key=332CA113&numwant=200&compact=1&no_peer_id=1&supportcrypto=1&redundant=0&ipv4=198.18.0.1&ipv6=2408%3a8214%3a2e11%3a8cb1%3a%3a9b8&ipv6=2408%3a8214%3a2e11%3a8cb1%3a7c27%3acac2%3a3b51%3a42fb&ipv6=2408%3a8214%3a2e11%3a8cb1%3ae0e7%3a8eb%3a4677%3a21f0

// 注：url 上有一些我们没提到的参数，是 tracker 的扩展协议加上去的，现在没必要深究
```

Tracker 的响应也是 bencode 编码。

如果 tracker 的响应了一个 **`failure reason`** key ，它的值是一个解释查询失败的原因的人类可读的字符串，且不会再有其他 key。除此之外，tracker 的响应应当有 2 个 key： 

- **interval**
    它表示 downloader 定期发起再次请求时，需要间隔的秒数。

- **peers**
    它的值是一个关于 peers 的字典列表，其中每一个元素都包含 `peer id`, `ip`, 和 `port` key，它们分别表示 peer 为自己选择的 ID，字符串形式的 IP 地址或域名，和端口号。

注意，如果发生了一个事件或者 downloader 需要更多的 peer，那么 downloader 可能会在非调度时间（即 interval 间隔时间）发起再次请求。

更常见的是 tracker 返回一个紧凑格式的 peer 列表，参见 [BEP0023](https://www.bittorrent.org/beps/bep_0023.html)

如果你想对 `metainfo` 文件或 Tracker 查询做扩展，请与 Bram Cohen 合作来确认所有扩展的兼容性。

通过 [BEP0015 - UDP tracker 协议](https://www.bittorrent.org/beps/bep_0015.html) 进行通告也很常见。

> *译注：可以看下，使用 json 格式展示的两种响应的例子*

```
// 失败的响应
{
    "failure reason": "This torrent not registered on this tracker."
}
```

```
// 成功的响应
{
    "interval": 3600,
    "peers": [
        {
            "ip": "192.168.1.1",
            "peer id": "-qB451%20-1MTFo0SteXN2"
            "port": 12345,
        },
        {
            "ip": "192.168.1.2",
            "peer id": "-qB451%20-%31MTFo0SteXN3"
            "port": 12346,
        }
    ]
}
```

## Peer 协议

BitTorrent 的 peer 协议操作基于 TCP 或 [uTP](https://www.bittorrent.org/beps/bep_0029.html)。

Peer 连接具有对称性。消息在两个方向上的发送看起来是一样的，数据可在任一方向上流动。

Peer 协议中使用了 metainfo 文件中的文件切片的索引，该索引是从 0 开始的。当一个 peer 下载完一个 切片，并且通过了该切片的 hash 校验，它就会通告（和它有连接，一起下载该资源文件的）其他 peer ，自己具有该切片。

一个连接的任一端都包含两个状态位： `choked` (阻塞) 或 `not choked` ， `interested` （感兴趣） 或 `not interested` 。阻塞是一种通知，在阻塞解除之前将不会发送任何数据。阻塞背后的原因及其常用技术，将在本文后面进行解释。

> *译注：A端发现B端有自己需要的数据，则会发送 interested 通知给 B 端；B 端如果不同意 A 端下载，则会发送 choked 通知给 A端。*

数据传输只有在一端发送了 interested 通知，同时另一端没有阻塞的情况下才会发生。Interest 状态必须保持时刻更新 - 不论是否被阻塞，任何时候，只要当一个 downloader 对向另一个 peer 没有需求时，它都要 (向对方) 表达不感兴趣 (发送 `not interested` 通知)。正确的实现这一点有点棘手，但这样做可以使 downloader 知道哪些 peers 在解除阻塞后，可以立刻进行下载。

> *译注：被 downloader 通知了 not interested 的 peer （同时 downdloader 在本地会维护该状态）， downloader 是不会去进行下载的；那么 downloader 一旦收到自己 interested 且被 choked 的 peer ，发送来 unchoked 通知时，就会立刻进行下载*

新建的连接处于 `choked` 和 `not interested` 状态。

当数据传输时，downloader 应当在一次 (发送) 队列中放入数个 piece 请求，这样可以获得较好的 TCP 性能（这被称为 `pipelining` 流水线 ）。另一方面，无法写入 TCP 缓冲的请求，应当立即放入内存队列，而不是将其保存在应用层的网络缓冲区中，如果那样的话，当 downloader 收到 choked 通知时，这些请求会被清空。

> *译注：作者当时是使用 python 实现 BitTorrent downloader 的，python 是单线程的，所以，他所说的“应用层的网络缓冲区” 就是一个用于数据传输的全局缓存，当前 peer 的数据传输被阻塞时，就需要将全局缓存让出来给其他的 peer 的数据传输使用。*


