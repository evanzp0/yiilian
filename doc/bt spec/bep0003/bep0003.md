# <center>BitTorrent Protocol 规范</center>

BitTorrent 是一个用于文件分发的协议，它通过 URL 来标识内容，并被设计成与 web 无缝集成。它的相对于一般 HTTP 的优势在于，当相同的文件有多个下载并发进行时，下载者之间可互传数据，这使得文件源在仅增加少量负载的情况下就能支持数量众多的下载成为可能。

## 一个 BitTorrent 文件分发由以下实体组成：
- 一个普通的 web 服务器
    > *译注：存放 .torrent 种子文件的 web 服务器，比如可以下载附件的论坛等等*
- 一个静态的 'metainfo' 文件
    > *译注：这是以 .torrent 为扩展名的种子文件，它相当于是被下载资源文件的一个概述*
- 一个 BitTorrent tracker 服务器
    > *译注：让下载同一个文件的多个下载器之间能互相认识的一个服务器*
- 一个 '下载源' ('original' downloader)
    > *译注：拥有被下载资源文件 100% 内容，并将其提供给别人下载的下载器，俗称 '做种者'*
- 终端用户 web 浏览器
    > *译注：终端用户通过 web 浏览器，在 web 服务器上下载到 .torrent 种子文件*
- 终端用户下载器(downloader)
    > *译注：终端用户通过下载器 (downloader)，下载 .torrent 种子文件对应的资源文件*

理想情况下，一个单独的文件有多个终端用户在下载。

## 要提供 Bittorent 下载服务，主机端需要执行以下步骤：
1. 启动运行一个 tracker 服务器(或者，更可能的是有一个已经运行的 tracker)。
2. 启动运行一个普通的 web 服务器，比如 apache ，或者有一个已经运行的。
3. 在该 web 服务器上将 `.torrent` 扩展名和 `mimetype applicaton/x-bittorrent` 进行关联（或者已经完成此操作）。
4. 使用要发布的完整文件和 tracker 服务器的 url，生成一个 `metainfo` (`.torrent`) 文件。
5. 将 `metainfo` 文件放到 web 服务器上。
6. 将 `metainfo` (`.torrent`) 文件的链接放入某个 web 页面中。
7. 启动一个已经有了完整文件的 downloader (the 'origin')

> *译注：总结一下，提供 BitTorrent 文件下载服务，需要如下步骤：*
>
> *1. 启动 Tracker 服务。*
> *2. `.torrent` 文件的生成和发布：这包括根据要发布的文件本身的内容和 Tracker 服务器的 URL 生成 `metainfo` 文件，即 `.torrent` 文件；将 `.torrent` 文件发布到 Web 服务器上，提供对该 `.torrent` 文件的下载服务；将 `.torrent` 文件的链接尽可能的传播出去。*
> *3.启动提供文件的下载源。*
>
> *真正用于实际的文件下载的组件是 Tracker 服务器，和文件的下载源节点。*

## 要启动下载，用户需要执行以下步骤：
1. 安装 BitTorrent (或已经安装完成该操作)。
2. 浏览 web 。
3. 点击 `.torrent` 文件的链接。
4. 选择保存资源文件的本地路径，或者选择一个部分下载的资源文件并恢复下载。
5. 等待下载完成。。
6. 退出下载器 (它会持续上传数据直到退出)

> *译注：总结一下，BitTorrent 文件下载有两个过程：*
> *一是下载 `.torrent` 文件；*
> *二是使用 BitTorrent 客户端下载文件，数据的来源将是网络中包含文件数据的其它节点。*

## Bencode 编码
- 字符串(string)表示为：十进制的长度前缀，后接冒号和字符串本身。
    *例如：`spam` 的编码为 `4:spam`*
- 整数(integer)表示为：`i`开头，后接十进制的数字，然后跟一个 `e` 表示结束。
    *例如：`3` 的编码为 `i3e`；`-3` 的编码为 `i-3e`*
    整数没有大小限制，`i-0e` 是无效的。除了表示 0 的 `i0e` 以外，所有以 0 为开头的编码，比如：`i03e`，都是无效的。
- 列表(list)表示为：`l` 开头，后接列表元素（这些元素也是 B 编码的），然后用 `e` 表示结束。
     *例如：`['spam', 'eggs']` 的编码为 `l4:spam4:eggse`*
- 字典(dictionary)表示为：`d`开头，后面交替跟着 `key` 及其对应的 `value` ，然后用 `e` 表示结束。
    *例如： `{'cow': 'moo', 'spam': 'eggs'}` 的编码为 `d3:cow3:moo4:spam4:eggse`; `{'spam': ['a', 'b']}` 的编码为 `d4:spaml1:a1:bee`*
    Key 必须为字符串并且顺序排列（按照原始字符（raw string）串排序，而不是字母顺序）

> *译注： `BitTorrent` 协议发明了一种编码方式，即 `Bencode` 。 `Bencode` 编码有 4 种数据类型，即字符串，整数，列表，和字典（即映射）。基本数据类型是字符串和数字，列表和字典则是两种最常用的容器类型。*

## metainfo 文件
Metainfo 文件（也就是以 `.torrent` 为扩展名的文件）被编码为 bencode 字典，具有以下 key：

**announce**

    表示 tracker 的 URL 。

**info**

    它的值是一个字典，接下来会描述该字典中的 key 。

## info 字典

- `name` 的值是一个 UTF-8 编码的字符串，建议用它作为保存文件或目录的名字。这存粹只是建议。

- `piece length` 的值是一个数字，代表文件切片的大小。为了便于传输，文件被分割为固定大小的切片，除了最后一片由于截断导致长度可能与众不同外，所有切片的长度都是相同的。`piece length` 几乎总是 2 的幂，最常见的是 2 ^ 18 = 256 K （BitTorrent 在 3.2 版之前使用 2 ^ 20 = 1M 作为默认值）。

- `pieces` 的值是一个字符串，它的长度是 20 的整数倍。它被分段为长度为 20 的若干字符串，每个分段字符串，都是其分段索引对应的文件切片的 SHA1 hash 值。

- 还有一个 `length` 或 `files` 的 key，但它们有且只能有其中一个出现。如果出现 `length` ，那么代表下载的是一个单个的文件，否则，代表下载的是一个目录结构下的一系列文件。

    单个文件的情况下， `length` 表示文件的字节长度。

    出于其他键的目的，多文件的情况，仅被看作将 `files` 列表中出现的文件，按顺序连接形成的单个文件。

    > *译注：这句话的意思是，从 `pieces` 这种 key 的角度看，多个文件实际上是按顺序连接成一个大文件，然后进行切片处理。*

- `files` 的值是文件列表 ，它的元素是包含以下 key 的字典：

    - `length` - 文件的长度，以字节为单位。
    - `path` - UTF-8编码的字符串，其中有相应的子目录名和文件名（ path 字符串的长度不可为 0 ）

单个文件情况下，`name` 的值可作为文件名；多个文件的情况下，`name` 的值可作为目录名。

> *译注：用 JSON 来表示 .torrent 文件使我们可以对这种文件格式的结构有更清晰的认识。*

```
// 单个文件的 .torrent 文件结构
{
    "announce":"xxxx",
    "info":{
        "name":"xxxx",
        "piece length":"xxxx",
        "pieces":"xxxx",
        "length":"xxxx"
    }
}
```

```
// 多个文件的 .torrent 文件结构
{
    "announce":"xxxx",
    "info":{
        "name":"xxxx",
        "piece length":"xxxx",
        "pieces":"xxxx",
        "files":[
            {
                "length":"xxxx",
                "path":"xxxx"
            },
            {
                "length":"xxxx",
                "path":"xxxx"
            },
            {
                "length":"xxxx",
                "path":"xxxx"
            }
        ]
    }
}
```

## tracker

Tracker 的 Get 请求有以下 key:

- **info hash**
    它是将 `metainfo` 文件中 `info` 的 bencode 编码值，进行 SHA1 后得到的 20个字节的 hash 值。由于要通过 http get 将该值作为参数值向 tracker 发送请求，所以几乎肯定要该值进行 (URL) 转码。

    注意，这是 `metainfo` 文件的一个子字符串。`info-hash` 必须是 .torrent 中找到的已编码的子字符串的 hash 值，它等同于，先用 bencode 解码 `metainfo` 文件，接着**完全校验解码后的内容**（ 比如 key 的排序，没有前导 0 ），校验通过后提取 `info` 的值进行 bencode 编码。换句话说，这意味着客户端不能使用无效的 `metainfo` 文件，也不能直接使用提取的 bencode 子字符串。
    > *译注：这里是指，不能直接使用提取的 `info` 的 bencode 的值进行 hash，需要先校验其有效性*。
    
    它们不得在无效得数据上进行解码和编码循环
    > *译注：这里是指，如果 `metainfo` 文件是无效的，那不仅经过校验，就对 `info` 的值进行 bencode 解码，然后再进行 bencode 编码，最终得到得 hash 将是错误的*。

- **peer_id**
   向 tracker 发起请求的 downloader 的 id，它是一个长度为 20 的字符串。**Downloader 应在每次开始一个新的下载任务时重新随机生成一个新的 peer_id**，该值也几乎肯定要会被 (URL) 转码。

- **ip**
    一个可选的参数，它给出了这个 peer 的 IP (或域名)。如果 peer 与 tracker 位于相同机器的话，会使用该参数作为 peer 的源（地址），否则通常不需要。
    > *译注：*
    > - *一般情况下该参数没有必要, 因为传输层 (Transport Layer, 如 TCP) 本身可以获取 IP 地址, 但如果 BT 下载器通过 Proxy 与 Tracker 交互时, 该在该字段中设置源端的真实 IP 。*
    > - *另外，如果 peer 和 tracker 位于同一台机器，那么通过传输层获得的地址是可能是 127.0.0.1，这个地址是不能和外网的 peer 进行通信的，所以要指定一个 peer 的外网 IP 才行 。*

